# Design Messenger
This problem may be asked in various ways such as designing Facebook Messenger or designing WhatsApp.
Yet, there are some differences between these products. For example, for security and privacy concerns, WhatsApp works as a message broker that does not store messages in its backend database once messages are delivered to users.
Here, I design the system as a general messenger that marshalls messages among users and stores messages in the backend as well.


## Feature Requirement

### Functional Requirement
1. The system should support 1-on-1 chat between users.
2. The system should keep track of the online or offline status of the users.
3. Users should be able to identify if their message are sent, delivered, or seen.

### Non-Functional requirement
1. Users should have real-time chat experience with minimum latency.
2. The messenger must be highly available.

### Extended Features
1. Support group chat.
2. Transmit photos or videos.


## Capacity Estimation

### Traffic
Assume we have 1B daily active users and on average each user sends 50 messages every day. Then, the traffic rate would be 50B requests/day, or 600K requests/second.

### Storage
Assume that the average size of a message is 100 bytes. Then, the daily data generation pace would be 50B * 100 = 5TB / day.


## High-Level Component Design
<p align="center">
  <img src="https://github.com/ZSShen/Hacking-Tech-Interview/blob/main/SystemDesign/Messenger/photos/HighLevelDesign.jpg"/>
</p>

## Database Schema
<p align="center">
  <img src="https://github.com/ZSShen/Hacking-Tech-Interview/blob/main/SystemDesign/Messenger/photos/DatabaseSchema.jpg"/>
</p>


## Detailed Component Design

### 1-on-1 Chat

The data flow of 1-on-1 chat is comprised of the following steps:
1. The sender sends a message to a gateway, which in turn forwards the message to `MessageService`.
2. `MessageService` checks if the specified receiver is online by querying `UserService`.
3. If the receiver is online, the producer component of `MessageService` pushes the message into the message queue, and then the consumer component later retrieves it and sends it to the receiver.
4. Meanwhile, an asynchronous task is launched by `MessageService` to store the message through interacting with `RepositoryService`.

<p align="center">
  <img src="https://github.com/ZSShen/Hacking-Tech-Interview/blob/main/SystemDesign/Messenger/photos/ChatDataFlow.jpg"/>
</p>

### User Login
When a user logs into the messenger app, the app will connect to the backend `UserService` through a gateway for record updating, such as online status. Then, `UserService` notifies `MessageService` to check the messages which have not been seen by the user and send them  to the user. Besides, the messenger app will send heartbeat messages regularly to `UserService` so that it can maintain the online status for the user.

### Message Status
In general, we define three message status codes: sent, delivered, and seen.

#### Sent
When `MessageService` receives a message from a user, it replies an `ACK` to the messenger app. Then, the app will generate a check mark to notify the user. 

#### Delivered
When the message is delivered to the receiver, `MessageService` will send another `ACK` to the messenger app. This time, another check mark will be generated by the app.

#### Seen
When the receiver sees the message, his app will notify `MessageService`, which in turn sends another `ACK` to the sender's app. Upon receiving the `ACK`, the two marks shown on the sender's app will be highlighted.  

### Group Chat
The flow of group chat is similar to 1-on-1 chat. Upon receiving a message, `MessageService` queries `UserService` to get all the members of the chat group and then sends the message to all the message queues of these users, also called fan-out-on-write. Meanwhile, `MessageService` stores the message in `GroupChatDB` .

### Multimedia Content
We should store photos or videos in a distributed file system like Amazon S3 or HDFS. Essentially, If there is a photo in a chat message, the message body only embeds a link to the resource instead of carrying the photo directly. Once the user hovers on or clicks the link, the messenger app will load the resource by accessing the CDN or querying the backend system. This way, we reduce the size of a message body.

## Scale-Out

### Database Sharding
We can shard `UserDB`  using `UserId` as the sharding key and shard `MessageDB` using `MessageId` as the sharding key. Moreover, we should apply consistent hash to avoid unbalanced load distribution.

### Cache
For the database, we must turn on its caching mechanism. Plus, we should use a caching system like Memcached to optimize accessing `MessageDB`. Furthermore, we deploy CDN to cache hot photos or videos for fast access in different geolocations. 

### Fault Tolerance
For each service, such as `UserService` and `MessageService`, we launch multiple servers and prepare load balancers in front of them to evenly distribute the workload.

For the database sub-system, we should avoid single-point-of-failure by implementing the master-slave architecture; the master handles write requests, while the slaves handle read requests. Besides, once the master is down, the zookeeper should organize the election process to promote a new master among the remaining slaves.
